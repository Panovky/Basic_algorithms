"""
Алгоритм Евклида (Euclidean algorithm) - алгоритм нахождения наибольшего общего делителя (НОД) двух целых чисел.

1. Базовый алгоритм Евклида вычитанием

В самом простом случае алгоритм применяется к паре целых чисел и формирует новую пару чисел,
которая состоит из меньшего числа и разницы между большим и меньшим числом. Процесс повторяется
до тех пор, пока числа в паре не станут равны. Это и будет искомый НОД

gcd (the greatest common divisor) - наибольший общий делитель
"""


def gcd_11(a: int, b: int) -> int:  # рекурсивная реализация

    if a == b:
        return a  # НОД найден

    if a > b:
        a = a - b  # из большего числа a вычитаем меньшее число b
    else:
        b = b - a  # из большего числа b вычитаем меньшее число a

    return gcd_11(a, b)


def gcd_12(a: int, b: int) -> int:  # реализация с использованием цикла while

    while a != b:
        if a > b:
            a = a - b
        else:
            b = b - a

    return a  # искомый НОД (=b)


"""
2. Базовый алгоритм Евклида делением

Этот способ отличается от первого тем, что операция вычитания из большего числа меньшего заменяется на
операцию взятия остатка от деления большего числа на меньшее число. Деление продолжается до тех пор, пока
одно из чисел пары не будет равно нулю. В таком случае второе число пары - это искомый НОД.

"""


def gcd_21(a: int, b: int) -> int:  # рекурсивная реализация (число a больше числа b)

    if b == 0:  # одно из чисел равно нулю
        return a  # другое является НОД

    return gcd_21(b, a % b)  # большее число a заменяем на остаток от деления его на число b


def gcd_22(a: int, b: int) -> int:  # реализация с использованием цикла while (число a больше числа b)

    while b != 0:
        a, b = b, a % b

    return a  # искомый НОД


"""
3. Расширенный алгоритм Евклида 

Обычный алгоритм Евклида находит только НОД двух чисел a и b. Расширенный же алгоритм Евклида находит помимо НОД 
коэффициенты x и y такие, что:  ax + by = gcd(a, b). 

Расширенный алгоритм находит коэффициенты, с помощью которых НОД двух чисел может быть выражен через сами эти числа.

Выведем формулы, по которым коэффициенты меняются при переходе от пары (a, b) к паре (b, a % b).

1. Пусть мы знаем решение (x1, y1) для пары чисел (b, a % b): b * x1 + (a % b) * y1 = g.

2. Теперь необходимо получить решение (x, y) для пары чисел (a, b): ax + by = g.

3. Заменим выражение (a % b) на (a - [a//b] * b), где [a//b] - целая часть от деления числа a на число b.

4. Перепишем уравнение в виде: 

    b * x1 + (a - [a//b] * b) * y1 = g.

    b * x1 + a * y1 - [a//b] * b * y1 = g

    a * y1 + b * (x1 - [a//b] * y1) = g

5. Отсюда имеем, что x = y1,  y = x1 - [a//b] * y1

Замечание: в случае, если b = 0, число a является НОД. Тогда коэффициенты x = 1 и y = 0.

"""


def gcd_3(a: int, b: int) -> [int, int, int]:  # рекурсивная реализация (число a больше числа b)

    if b == 0:  # база рекурсии
        return a, 1, 0  # НОД = a, x = 1, y = 0

    g, x1, y1 = gcd_3(b, a % b)  # ищем коэффициенты для следующей пары чисел

    return g, y1, x1 - (a // b) * y1  # возвращаем коэффициенты для текущей пары чисел


